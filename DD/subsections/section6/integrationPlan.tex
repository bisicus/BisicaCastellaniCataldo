\subsubsection{Entry Criteria}
	In order to start a correct integration test we must ensure the following conditions are granted:

	\begin{itemize}
		\item Requirements Analysis and Specification Document as well as the Design Document must be complete in each section and up to date, reflecting the current state of the project
		\item All sub-components must be already unit tested and bug free
		\item Risk Assessment has been layed out since it'll serve us in critical-first module integration
	\end{itemize}

	In addition to this we assume that all algorithms that interface external agents and make use of APIs will be already tested and that they will work as intended in receiving external data when proceeding with integration (we're talking about all sub-components that contain the word 'API' in API Manager component).


\subsubsection{Elements to be integrated}
	All components we created and delimited in components diagram are going to be integrated. All components that give the chance to do so, will also be tested regarding the integration of the single subcomponents.

\subsubsection{Integration Testing Strategy}
	From a component perspective we can safely say we adopted a bottom-up policy for the integration plan, while we also used a critical-first approach in sub-components integration (requiring, therefore, stubs in such cases). 
	Our choice has mainly been driven by its ease and by the relatively small scale of our system.
	
	Sequence of component/function integration.
	It's time for us to detail the integration order of our components, delving in what we simply anticipated with our dependency diagrams.

	\begin{description}
	
	\item[Component]: API Manager.
		\textit{Internal integration strategy}: Bottom - Up.
		\textit{Integration order}:
		\begin{itemize}
			\item Google Maps API.
			\item OpenWeatherMap.
			\item Google Transit API.
			\item Car2Go API.
			\item BikeMi API.
			\item Other API-Based System.
			\item Listener.
		\end{itemize}


	\item[Component]: Travlendar Server.
		\textit{Internal integration strategy}: Critical - First.
		\textit{Integration order}:
		\begin{itemize}
			\item DBMS.
			\item API Request Dispatcher.
		\end{itemize}
	
	\item[Component]: Localization Manager doesn't need sub-components integration plan.

	\item[Component]: Notification Manager doesn't need sub-components integration plan.
	
	\item[Component]: Payment Manager.

		\textit{Internal integration strategy}: Bottom - Up.
		\textit{Integration order}:
		\begin{itemize}
			\item Payment Handler.
			\item Purchase History.
		\end{itemize}
	
	\item[Component]: Preference Manager.
		\textit{Internal integration strategy}: Bottom - Up
		\textit{Integration order}:
		\begin{itemize}
			\item Excluded Vehicles List.
			\item Season Pass Handler.
			\item Preferences List.
			\item Preference Handler.
		\end{itemize}
	
	\item[Component]: Travel Logic.
		\textit{Internal integration strategy}: Bottom - Up
		\textit{Integration order}:
		\begin{itemize}	
			\item Trip Handler.
			\item Scheduler.
		\end{itemize}
	
	\item[Component]: Mobile Application.
		\textit{Internal integration strategy}: Critical - First.
		\textit{Integration order}:
		\begin{itemize}
			\item User View.
			\item Guest View.
		\end{itemize}
	
	\item[Component]: Calendar Manager.
	\textit{Internal integration strategy}: Bottom - Up.
	\textit{Integration order}:
	\begin{itemize}
		\item Trip List.
		\item Break List.
		\item Appointment Aggregator.
	\end{itemize}

	\item[Component]: Access Manager.
		\textit{Internal integration strategy}: Critical - first.
		\textit{Integration order}:
		\begin{itemize}
			\item Authentication Manager.
			\item SignUp Handler.
			\item Saved Login Data.
		\end{itemize}
		
	\item[Component]: Application Aggregator.
		\textit{Internal integration strategy}: Critical-First.
		\textit{Integration order}:
		\begin{itemize}
			\item Profile Manager.
			\item User Actions Handler.
		\end{itemize}
		
	\end{description}

\subsubsection{Individual Steps and Test Description}
 
	The components will be tested following the interfaces they share and that we previously described, testing core methods also in case of sub-components integration.
	Our main goal is to spot any kind of faults and failures, focusing in particular on input domains, covering the restricted spectrum of system reactions.
	Because of this, we'll detail the tests in easy-to-consult tables, each introduced by the components and subcomponents that are required.
	Each table represents an interface method, and on two columns we'll detail each input and its expected result.